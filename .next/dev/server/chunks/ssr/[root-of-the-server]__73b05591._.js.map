{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/config.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - Configuration Module\r\n * Handles API base URL, network settings, and environment configuration\r\n */\r\n\r\nlet config = null;\r\n\r\n/**\r\n * Default configuration\r\n */\r\nconst DEFAULT_CONFIG = {\r\n  apiBaseUrl: 'http://localhost:8080',\r\n  network: 'testnet', // 'testnet' | 'mainnet'\r\n  algodUrl: 'https://testnet-api.algonode.cloud',\r\n  algodToken: '',\r\n  algodPort: '',\r\n  indexerUrl: 'https://testnet-idx.algonode.cloud',\r\n  indexerToken: '',\r\n  indexerPort: '',\r\n  asaId: null, // PlayCoin ASA ID\r\n  currency: 'PLY',\r\n  ratePerMinute: 0.02, // Default rate in EUR\r\n  autoTopupThreshold: 1.00, // EUR\r\n  appId: null, // Smart Contract App ID\r\n  providerAddr: null,\r\n  platformAddr: null,\r\n  platformFeePct: 500, // 5% = 500 basis points\r\n  demoMode: false\r\n};\r\n\r\n/**\r\n * Initialize configuration\r\n * @param {Object} userConfig - User-provided configuration\r\n * @returns {Object} Configuration object\r\n */\r\nexport function initConfig(userConfig = {}) {\r\n  // Load from environment variables if available\r\n  const envConfig = {\r\n    apiBaseUrl: process.env.PLAYANDPAY_API_URL || DEFAULT_CONFIG.apiBaseUrl,\r\n    network: process.env.PLAYANDPAY_NETWORK || DEFAULT_CONFIG.network,\r\n    algodUrl: process.env.PLAYANDPAY_ALGOD_URL || DEFAULT_CONFIG.algodUrl,\r\n    indexerUrl: process.env.PLAYANDPAY_INDEXER_URL || DEFAULT_CONFIG.indexerUrl,\r\n    asaId: process.env.PLAYANDPAY_ASA_ID ? parseInt(process.env.PLAYANDPAY_ASA_ID) : null,\r\n    appId: process.env.PLAYANDPAY_APP_ID ? parseInt(process.env.PLAYANDPAY_APP_ID) : null,\r\n    providerAddr: process.env.PLAYANDPAY_PROVIDER_ADDR || null,\r\n    platformAddr: process.env.PLAYANDPAY_PLATFORM_ADDR || null,\r\n    apiKey: process.env.PLAYANDPAY_API_KEY || null\r\n  };\r\n\r\n  // Merge: userConfig > envConfig > DEFAULT_CONFIG\r\n  config = {\r\n    ...DEFAULT_CONFIG,\r\n    ...envConfig,\r\n    ...userConfig\r\n  };\r\n\r\n  // Set network-specific URLs if network changed\r\n  if (config.network === 'mainnet') {\r\n    config.algodUrl = config.algodUrl || 'https://mainnet-api.algonode.cloud';\r\n    config.indexerUrl = config.indexerUrl || 'https://mainnet-idx.algonode.cloud';\r\n  }\r\n\r\n  // Enable demo mode if critical config is missing\r\n  if (!config.asaId || !config.providerAddr) {\r\n    config.demoMode = true;\r\n  }\r\n\r\n  return config;\r\n}\r\n\r\n/**\r\n * Get current configuration\r\n * @returns {Object} Configuration object\r\n */\r\nexport function getConfig() {\r\n  if (!config) {\r\n    console.warn('⚠️  Config not initialized. Using defaults.');\r\n    return initConfig();\r\n  }\r\n  return config;\r\n}\r\n\r\n/**\r\n * Update configuration\r\n * @param {Object} updates - Configuration updates\r\n */\r\nexport function updateConfig(updates) {\r\n  if (!config) {\r\n    config = { ...DEFAULT_CONFIG };\r\n  }\r\n  config = { ...config, ...updates };\r\n  return config;\r\n}\r\n\r\n/**\r\n * Check if demo mode is enabled\r\n * @returns {boolean}\r\n */\r\nexport function isDemoMode() {\r\n  return getConfig().demoMode;\r\n}\r\n\r\n/**\r\n * Get API base URL\r\n * @returns {string}\r\n */\r\nexport function getApiBaseUrl() {\r\n  return getConfig().apiBaseUrl;\r\n}\r\n\r\n/**\r\n * Get Algorand network configuration\r\n * @returns {Object}\r\n */\r\nexport function getAlgorandConfig() {\r\n  const cfg = getConfig();\r\n  return {\r\n    algodUrl: cfg.algodUrl,\r\n    algodToken: cfg.algodToken,\r\n    algodPort: cfg.algodPort,\r\n    indexerUrl: cfg.indexerUrl,\r\n    indexerToken: cfg.indexerToken,\r\n    indexerPort: cfg.indexerPort\r\n  };\r\n}\r\n\r\nexport default {\r\n  initConfig,\r\n  getConfig,\r\n  updateConfig,\r\n  isDemoMode,\r\n  getApiBaseUrl,\r\n  getAlgorandConfig\r\n};\r\n\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;AAED,IAAI,SAAS;AAEb;;CAEC,GACD,MAAM,iBAAiB;IACrB,YAAY;IACZ,SAAS;IACT,UAAU;IACV,YAAY;IACZ,WAAW;IACX,YAAY;IACZ,cAAc;IACd,aAAa;IACb,OAAO;IACP,UAAU;IACV,eAAe;IACf,oBAAoB;IACpB,OAAO;IACP,cAAc;IACd,cAAc;IACd,gBAAgB;IAChB,UAAU;AACZ;AAOO,SAAS,WAAW,aAAa,CAAC,CAAC;IACxC,+CAA+C;IAC/C,MAAM,YAAY;QAChB,YAAY,QAAQ,GAAG,CAAC,kBAAkB,IAAI,eAAe,UAAU;QACvE,SAAS,QAAQ,GAAG,CAAC,kBAAkB,IAAI,eAAe,OAAO;QACjE,UAAU,QAAQ,GAAG,CAAC,oBAAoB,IAAI,eAAe,QAAQ;QACrE,YAAY,QAAQ,GAAG,CAAC,sBAAsB,IAAI,eAAe,UAAU;QAC3E,OAAO,QAAQ,GAAG,CAAC,iBAAiB,GAAG,SAAS,QAAQ,GAAG,CAAC,iBAAiB,IAAI;QACjF,OAAO,QAAQ,GAAG,CAAC,iBAAiB,GAAG,SAAS,QAAQ,GAAG,CAAC,iBAAiB,IAAI;QACjF,cAAc,QAAQ,GAAG,CAAC,wBAAwB,IAAI;QACtD,cAAc,QAAQ,GAAG,CAAC,wBAAwB,IAAI;QACtD,QAAQ,QAAQ,GAAG,CAAC,kBAAkB,IAAI;IAC5C;IAEA,iDAAiD;IACjD,SAAS;QACP,GAAG,cAAc;QACjB,GAAG,SAAS;QACZ,GAAG,UAAU;IACf;IAEA,+CAA+C;IAC/C,IAAI,OAAO,OAAO,KAAK,WAAW;QAChC,OAAO,QAAQ,GAAG,OAAO,QAAQ,IAAI;QACrC,OAAO,UAAU,GAAG,OAAO,UAAU,IAAI;IAC3C;IAEA,iDAAiD;IACjD,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,YAAY,EAAE;QACzC,OAAO,QAAQ,GAAG;IACpB;IAEA,OAAO;AACT;AAMO,SAAS;IACd,IAAI,CAAC,QAAQ;QACX,QAAQ,IAAI,CAAC;QACb,OAAO;IACT;IACA,OAAO;AACT;AAMO,SAAS,aAAa,OAAO;IAClC,IAAI,CAAC,QAAQ;QACX,SAAS;YAAE,GAAG,cAAc;QAAC;IAC/B;IACA,SAAS;QAAE,GAAG,MAAM;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO;AACT;AAMO,SAAS;IACd,OAAO,YAAY,QAAQ;AAC7B;AAMO,SAAS;IACd,OAAO,YAAY,UAAU;AAC/B;AAMO,SAAS;IACd,MAAM,MAAM;IACZ,OAAO;QACL,UAAU,IAAI,QAAQ;QACtB,YAAY,IAAI,UAAU;QAC1B,WAAW,IAAI,SAAS;QACxB,YAAY,IAAI,UAAU;QAC1B,cAAc,IAAI,YAAY;QAC9B,aAAa,IAAI,WAAW;IAC9B;AACF;uCAEe;IACb;IACA;IACA;IACA;IACA;IACA;AACF","debugId":null}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/utils.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - Utility Functions\r\n * Logger, formatters, and helper functions\r\n */\r\n\r\n/**\r\n * Logger utility\r\n */\r\nexport const logger = {\r\n  enabled: process.env.NODE_ENV !== 'production',\r\n  \r\n  log(...args) {\r\n    if (this.enabled) {\r\n      console.log('[PlayAndPay]', ...args);\r\n    }\r\n  },\r\n  \r\n  error(...args) {\r\n    console.error('[PlayAndPay] ERROR:', ...args);\r\n  },\r\n  \r\n  warn(...args) {\r\n    if (this.enabled) {\r\n      console.warn('[PlayAndPay] WARN:', ...args);\r\n    }\r\n  },\r\n  \r\n  debug(...args) {\r\n    if (this.enabled && process.env.DEBUG) {\r\n      console.debug('[PlayAndPay] DEBUG:', ...args);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Format amount from minor units to major units\r\n * @param {number} minor - Amount in minor units (cents)\r\n * @param {number} decimals - Decimal places (default: 2)\r\n * @returns {number}\r\n */\r\nexport function formatAmount(minor, decimals = 2) {\r\n  return minor / Math.pow(10, decimals);\r\n}\r\n\r\n/**\r\n * Convert EUR to PLY minor units\r\n * @param {number} eur - Amount in EUR\r\n * @param {number} rate - Conversion rate (1 PLY = rate EUR, default: 0.01)\r\n * @returns {number} PLY minor units\r\n */\r\nexport function eurToPLYMinor(eur, rate = 0.01) {\r\n  return Math.round(eur / rate);\r\n}\r\n\r\n/**\r\n * Convert PLY minor units to EUR\r\n * @param {number} plyMinor - Amount in PLY minor units\r\n * @param {number} rate - Conversion rate (1 PLY = rate EUR, default: 0.01)\r\n * @returns {number} EUR amount\r\n */\r\nexport function plyMinorToEUR(plyMinor, rate = 0.01) {\r\n  return plyMinor * rate;\r\n}\r\n\r\n/**\r\n * Convert minutes to milliseconds\r\n * @param {number} minutes\r\n * @returns {number}\r\n */\r\nexport function minutesToMs(minutes) {\r\n  return minutes * 60 * 1000;\r\n}\r\n\r\n/**\r\n * Convert milliseconds to minutes\r\n * @param {number} ms\r\n * @returns {number}\r\n */\r\nexport function msToMinutes(ms) {\r\n  return ms / (60 * 1000);\r\n}\r\n\r\n/**\r\n * Generate unique ID\r\n * @param {string} prefix - Prefix for ID\r\n * @returns {string}\r\n */\r\nexport function generateId(prefix = 'id') {\r\n  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Generate tick ID for idempotency\r\n * @param {string} sessionId - Session ID\r\n * @param {number} timestamp - Timestamp\r\n * @returns {string}\r\n */\r\nexport function generateTickId(sessionId, timestamp = Date.now()) {\r\n  return `tick_${sessionId}_${timestamp}_${Math.random().toString(36).substr(2, 6)}`;\r\n}\r\n\r\n/**\r\n * Format duration (ms) to human-readable string\r\n * @param {number} ms - Duration in milliseconds\r\n * @returns {string}\r\n */\r\nexport function formatDuration(ms) {\r\n  const seconds = Math.floor(ms / 1000);\r\n  const minutes = Math.floor(seconds / 60);\r\n  const hours = Math.floor(minutes / 60);\r\n  \r\n  if (hours > 0) {\r\n    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;\r\n  } else if (minutes > 0) {\r\n    return `${minutes}m ${seconds % 60}s`;\r\n  } else {\r\n    return `${seconds}s`;\r\n  }\r\n}\r\n\r\n/**\r\n * Format currency amount\r\n * @param {number} amount - Amount\r\n * @param {string} currency - Currency code (default: 'EUR')\r\n * @returns {string}\r\n */\r\nexport function formatCurrency(amount, currency = 'EUR') {\r\n  return new Intl.NumberFormat('en-US', {\r\n    style: 'currency',\r\n    currency: currency\r\n  }).format(amount);\r\n}\r\n\r\n/**\r\n * Sleep/delay utility\r\n * @param {number} ms - Milliseconds to wait\r\n * @returns {Promise}\r\n */\r\nexport function sleep(ms) {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Retry utility\r\n * @param {Function} fn - Function to retry\r\n * @param {number} maxRetries - Maximum retries\r\n * @param {number} delay - Delay between retries (ms)\r\n * @returns {Promise}\r\n */\r\nexport async function retry(fn, maxRetries = 3, delay = 1000) {\r\n  for (let i = 0; i < maxRetries; i++) {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      if (i === maxRetries - 1) throw error;\r\n      logger.warn(`Retry ${i + 1}/${maxRetries} after error:`, error.message);\r\n      await sleep(delay * (i + 1)); // Exponential backoff\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Validate address format (Algorand)\r\n * @param {string} address - Address to validate\r\n * @returns {boolean}\r\n */\r\nexport function isValidAddress(address) {\r\n  if (!address || typeof address !== 'string') return false;\r\n  // Algorand addresses are 58 characters, base32 encoded\r\n  return /^[A-Z2-7]{58}$/.test(address);\r\n}\r\n\r\n/**\r\n * Validate session ID format\r\n * @param {string} sessionId - Session ID to validate\r\n * @returns {boolean}\r\n */\r\nexport function isValidSessionId(sessionId) {\r\n  if (!sessionId || typeof sessionId !== 'string') return false;\r\n  return /^session_[a-zA-Z0-9_]+$/.test(sessionId);\r\n}\r\n\r\nexport default {\r\n  logger,\r\n  formatAmount,\r\n  eurToPLYMinor,\r\n  plyMinorToEUR,\r\n  minutesToMs,\r\n  msToMinutes,\r\n  generateId,\r\n  generateTickId,\r\n  formatDuration,\r\n  formatCurrency,\r\n  sleep,\r\n  retry,\r\n  isValidAddress,\r\n  isValidSessionId\r\n};\r\n\r\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;CAEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACM,MAAM,SAAS;IACpB,SAAS,oDAAyB;IAElC,KAAI,GAAG,IAAI;QACT,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,QAAQ,GAAG,CAAC,mBAAmB;QACjC;IACF;IAEA,OAAM,GAAG,IAAI;QACX,QAAQ,KAAK,CAAC,0BAA0B;IAC1C;IAEA,MAAK,GAAG,IAAI;QACV,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,QAAQ,IAAI,CAAC,yBAAyB;QACxC;IACF;IAEA,OAAM,GAAG,IAAI;QACX,IAAI,IAAI,CAAC,OAAO,IAAI,QAAQ,GAAG,CAAC,KAAK,EAAE;YACrC,QAAQ,KAAK,CAAC,0BAA0B;QAC1C;IACF;AACF;AAQO,SAAS,aAAa,KAAK,EAAE,WAAW,CAAC;IAC9C,OAAO,QAAQ,KAAK,GAAG,CAAC,IAAI;AAC9B;AAQO,SAAS,cAAc,GAAG,EAAE,OAAO,IAAI;IAC5C,OAAO,KAAK,KAAK,CAAC,MAAM;AAC1B;AAQO,SAAS,cAAc,QAAQ,EAAE,OAAO,IAAI;IACjD,OAAO,WAAW;AACpB;AAOO,SAAS,YAAY,OAAO;IACjC,OAAO,UAAU,KAAK;AACxB;AAOO,SAAS,YAAY,EAAE;IAC5B,OAAO,KAAK,CAAC,KAAK,IAAI;AACxB;AAOO,SAAS,WAAW,SAAS,IAAI;IACtC,OAAO,GAAG,OAAO,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI;AAC7E;AAQO,SAAS,eAAe,SAAS,EAAE,YAAY,KAAK,GAAG,EAAE;IAC9D,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,EAAE,UAAU,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI;AACpF;AAOO,SAAS,eAAe,EAAE;IAC/B,MAAM,UAAU,KAAK,KAAK,CAAC,KAAK;IAChC,MAAM,UAAU,KAAK,KAAK,CAAC,UAAU;IACrC,MAAM,QAAQ,KAAK,KAAK,CAAC,UAAU;IAEnC,IAAI,QAAQ,GAAG;QACb,OAAO,GAAG,MAAM,EAAE,EAAE,UAAU,GAAG,EAAE,EAAE,UAAU,GAAG,CAAC,CAAC;IACtD,OAAO,IAAI,UAAU,GAAG;QACtB,OAAO,GAAG,QAAQ,EAAE,EAAE,UAAU,GAAG,CAAC,CAAC;IACvC,OAAO;QACL,OAAO,GAAG,QAAQ,CAAC,CAAC;IACtB;AACF;AAQO,SAAS,eAAe,MAAM,EAAE,WAAW,KAAK;IACrD,OAAO,IAAI,KAAK,YAAY,CAAC,SAAS;QACpC,OAAO;QACP,UAAU;IACZ,GAAG,MAAM,CAAC;AACZ;AAOO,SAAS,MAAM,EAAE;IACtB,OAAO,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;AACpD;AASO,eAAe,MAAM,EAAE,EAAE,aAAa,CAAC,EAAE,QAAQ,IAAI;IAC1D,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,IAAK;QACnC,IAAI;YACF,OAAO,MAAM;QACf,EAAE,OAAO,OAAO;YACd,IAAI,MAAM,aAAa,GAAG,MAAM;YAChC,OAAO,IAAI,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,WAAW,aAAa,CAAC,EAAE,MAAM,OAAO;YACtE,MAAM,MAAM,QAAQ,CAAC,IAAI,CAAC,IAAI,sBAAsB;QACtD;IACF;AACF;AAOO,SAAS,eAAe,OAAO;IACpC,IAAI,CAAC,WAAW,OAAO,YAAY,UAAU,OAAO;IACpD,uDAAuD;IACvD,OAAO,iBAAiB,IAAI,CAAC;AAC/B;AAOO,SAAS,iBAAiB,SAAS;IACxC,IAAI,CAAC,aAAa,OAAO,cAAc,UAAU,OAAO;IACxD,OAAO,0BAA0B,IAAI,CAAC;AACxC;uCAEe;IACb;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACF","debugId":null}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/wallet.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - Wallet Module\r\n * Handles Algorand ASA wallet operations (balance, transfers)\r\n */\r\n\r\nimport algosdk from 'algosdk';\r\nimport { getConfig, getAlgorandConfig, isDemoMode } from './config.js';\r\nimport { logger, isValidAddress } from './utils.js';\r\n\r\nlet algodClient = null;\r\nlet indexerClient = null;\r\n\r\n/**\r\n * Initialize Algorand clients\r\n */\r\nfunction initClients() {\r\n  if (algodClient && indexerClient) {\r\n    return;\r\n  }\r\n  \r\n  const algodConfig = getAlgorandConfig();\r\n  algodClient = new algosdk.Algodv2(\r\n    algodConfig.algodToken,\r\n    algodConfig.algodUrl,\r\n    algodConfig.algodPort\r\n  );\r\n  \r\n  indexerClient = new algosdk.Indexer(\r\n    algodConfig.indexerToken,\r\n    algodConfig.indexerUrl,\r\n    algodConfig.indexerPort\r\n  );\r\n  \r\n  logger.debug('Algorand clients initialized');\r\n}\r\n\r\n/**\r\n * Get wallet balance\r\n * @param {string} address - Algorand address\r\n * @returns {Promise<Object>} Balance object\r\n */\r\nexport async function getBalance(address) {\r\n  if (!address || !isValidAddress(address)) {\r\n    throw new Error('Invalid address');\r\n  }\r\n  \r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock balance');\r\n    return {\r\n      address,\r\n      balanceMinor: 50000, // 500 PLY (50000 minor units)\r\n      balance: 500.00,\r\n      currency: getConfig().currency || 'PLY'\r\n    };\r\n  }\r\n  \r\n  try {\r\n    initClients();\r\n    const config = getConfig();\r\n    const asaId = config.asaId;\r\n    \r\n    if (!asaId) {\r\n      throw new Error('ASA ID not configured');\r\n    }\r\n    \r\n    const accountInfo = await indexerClient.lookupAccountByID(address).do();\r\n    const asset = accountInfo.account.assets?.find(a => a['asset-id'] === asaId);\r\n    const balanceMinor = asset ? asset.amount : 0;\r\n    const balance = balanceMinor / 100; // Assuming 2 decimals\r\n    \r\n    logger.debug(`Balance for ${address}: ${balance} ${config.currency}`);\r\n    \r\n    return {\r\n      address,\r\n      balanceMinor,\r\n      balance,\r\n      currency: config.currency || 'PLY'\r\n    };\r\n  } catch (error) {\r\n    logger.error('Error getting balance:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Transfer ASA tokens\r\n * @param {string} fromAddress - Sender address\r\n * @param {string} toAddress - Receiver address\r\n * @param {number} amountMinor - Amount in minor units\r\n * @param {Object} signer - Signer object (mnemonic or wallet connector)\r\n * @returns {Promise<Object>} Transaction result\r\n */\r\nexport async function transfer(fromAddress, toAddress, amountMinor, signer) {\r\n  if (!isValidAddress(fromAddress) || !isValidAddress(toAddress)) {\r\n    throw new Error('Invalid address');\r\n  }\r\n  \r\n  if (amountMinor <= 0) {\r\n    throw new Error('Amount must be positive');\r\n  }\r\n  \r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock transaction');\r\n    return {\r\n      txId: `DEMO-TX-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n      amountMinor,\r\n      fromAddress,\r\n      toAddress,\r\n      confirmed: false\r\n    };\r\n  }\r\n  \r\n  try {\r\n    initClients();\r\n    const config = getConfig();\r\n    const asaId = config.asaId;\r\n    \r\n    if (!asaId) {\r\n      throw new Error('ASA ID not configured');\r\n    }\r\n    \r\n    // Get transaction parameters\r\n    const params = await algodClient.getTransactionParams().do();\r\n    \r\n    // Create asset transfer transaction\r\n    const txn = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\r\n      from: fromAddress,\r\n      to: toAddress,\r\n      amount: amountMinor,\r\n      assetIndex: asaId,\r\n      suggestedParams: params\r\n    });\r\n    \r\n    // Sign transaction\r\n    let signedTxn;\r\n    if (typeof signer === 'string') {\r\n      // Mnemonic\r\n      const account = algosdk.mnemonicToSecretKey(signer);\r\n      signedTxn = txn.signTxn(account.sk);\r\n    } else if (signer && typeof signer.signTransaction === 'function') {\r\n      // Wallet connector (e.g., Pera Wallet)\r\n      signedTxn = await signer.signTransaction([txn]);\r\n    } else {\r\n      throw new Error('Invalid signer. Provide mnemonic string or wallet connector.');\r\n    }\r\n    \r\n    // Submit transaction\r\n    const { txId } = await algodClient.sendRawTransaction(signedTxn).do();\r\n    logger.debug(`Transaction submitted: ${txId}`);\r\n    \r\n    // Wait for confirmation\r\n    const confirmation = await algosdk.waitForConfirmation(algodClient, txId, 4);\r\n    \r\n    logger.debug(`Transaction confirmed in round ${confirmation['confirmed-round']}`);\r\n    \r\n    return {\r\n      txId,\r\n      amountMinor,\r\n      fromAddress,\r\n      toAddress,\r\n      confirmed: true,\r\n      confirmedRound: confirmation['confirmed-round']\r\n    };\r\n  } catch (error) {\r\n    logger.error('Error transferring tokens:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if address has opted in to ASA\r\n * @param {string} address - Algorand address\r\n * @returns {Promise<boolean>}\r\n */\r\nexport async function isOptedIn(address) {\r\n  if (!address || !isValidAddress(address)) {\r\n    return false;\r\n  }\r\n  \r\n  if (isDemoMode()) {\r\n    return true; // Assume opted in for demo\r\n  }\r\n  \r\n  try {\r\n    initClients();\r\n    const config = getConfig();\r\n    const asaId = config.asaId;\r\n    \r\n    if (!asaId) {\r\n      return false;\r\n    }\r\n    \r\n    const accountInfo = await indexerClient.lookupAccountByID(address).do();\r\n    return accountInfo.account.assets?.some(a => a['asset-id'] === asaId) || false;\r\n  } catch (error) {\r\n    logger.error('Error checking opt-in:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Get transaction history for an address\r\n * @param {string} address - Algorand address\r\n * @param {number} limit - Maximum number of transactions\r\n * @returns {Promise<Array>} Transaction history\r\n */\r\nexport async function getTransactionHistory(address, limit = 50) {\r\n  if (!address || !isValidAddress(address)) {\r\n    throw new Error('Invalid address');\r\n  }\r\n  \r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock transaction history');\r\n    return [];\r\n  }\r\n  \r\n  try {\r\n    initClients();\r\n    const config = getConfig();\r\n    const asaId = config.asaId;\r\n    \r\n    const transactions = await indexerClient\r\n      .lookupAccountTransactions(address)\r\n      .assetID(asaId)\r\n      .limit(limit)\r\n      .do();\r\n    \r\n    return transactions.transactions || [];\r\n  } catch (error) {\r\n    logger.error('Error getting transaction history:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport default {\r\n  getBalance,\r\n  transfer,\r\n  isOptedIn,\r\n  getTransactionHistory\r\n};\r\n\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/wallet-connect.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - WalletConnect Module\r\n * Handles Pera Wallet connection and user-side transaction signing\r\n */\r\n\r\nimport { getConfig } from './config.js';\r\nimport { logger } from './utils.js';\r\n\r\nlet peraWallet = null;\r\nlet isConnected = false;\r\nlet connectedAddress = null;\r\n\r\n/**\r\n * Initialize Pera Wallet\r\n */\r\nexport async function initPeraWallet() {\r\n    if (typeof window === 'undefined') {\r\n        logger.warn('Pera Wallet can only be used in browser environment');\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        // Dynamic import for browser only\r\n        const { PeraWalletConnect } = await import('@perawallet/connect');\r\n        peraWallet = new PeraWalletConnect({\r\n            chainId: getConfig().network === 'mainnet' ? 416002 : 416003, // TestNet\r\n            shouldShowSignTxnToast: true\r\n        });\r\n        \r\n        logger.debug('Pera Wallet initialized');\r\n        return peraWallet;\r\n    } catch (error) {\r\n        logger.error('Error initializing Pera Wallet:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Connect to Pera Wallet\r\n * @returns {Promise<string>} Connected wallet address\r\n */\r\nexport async function connectWallet() {\r\n    if (!peraWallet) {\r\n        peraWallet = await initPeraWallet();\r\n    }\r\n\r\n    if (!peraWallet) {\r\n        throw new Error('Pera Wallet not available. Make sure @perawallet/connect is installed.');\r\n    }\r\n\r\n    try {\r\n        const accounts = await peraWallet.connect();\r\n        \r\n        if (accounts && accounts.length > 0) {\r\n            isConnected = true;\r\n            connectedAddress = accounts[0];\r\n            logger.debug('Wallet connected:', connectedAddress);\r\n            return connectedAddress;\r\n        } else {\r\n            throw new Error('No accounts returned from wallet');\r\n        }\r\n    } catch (error) {\r\n        if (error.data?.type !== 'CONNECT_MODAL_CLOSED') {\r\n            logger.error('Error connecting wallet:', error);\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Disconnect from Pera Wallet\r\n */\r\nexport async function disconnectWallet() {\r\n    if (peraWallet) {\r\n        try {\r\n            await peraWallet.disconnect();\r\n            isConnected = false;\r\n            connectedAddress = null;\r\n            logger.debug('Wallet disconnected');\r\n        } catch (error) {\r\n            logger.error('Error disconnecting wallet:', error);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get connected wallet address\r\n * @returns {string|null} Connected address or null\r\n */\r\nexport function getConnectedAddress() {\r\n    return connectedAddress;\r\n}\r\n\r\n/**\r\n * Check if wallet is connected\r\n * @returns {boolean}\r\n */\r\nexport function isWalletConnected() {\r\n    return isConnected && connectedAddress !== null;\r\n}\r\n\r\n/**\r\n * Sign transactions using Pera Wallet\r\n * @param {Array} transactions - Array of unsigned transactions\r\n * @returns {Promise<Array>} Array of signed transactions\r\n */\r\nexport async function signTransactions(transactions) {\r\n    if (!isConnected || !peraWallet) {\r\n        throw new Error('Wallet not connected. Call connectWallet() first.');\r\n    }\r\n\r\n    try {\r\n        // Pera Wallet expects array of transactions\r\n        const signedTxns = await peraWallet.signTransaction(Array.isArray(transactions) ? transactions : [transactions]);\r\n        logger.debug('Transactions signed successfully');\r\n        return Array.isArray(signedTxns) ? signedTxns : [signedTxns];\r\n    } catch (error) {\r\n        if (error.data?.type !== 'SIGN_MODAL_CLOSED') {\r\n            logger.error('Error signing transactions:', error);\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Sign a single transaction\r\n * @param {Object} transaction - Unsigned transaction object\r\n * @returns {Promise<Uint8Array>} Signed transaction\r\n */\r\nexport async function signTransaction(transaction) {\r\n    const signed = await signTransactions([transaction]);\r\n    return signed[0];\r\n}\r\n\r\n/**\r\n * Reconnect to previously connected wallet\r\n */\r\nexport async function reconnectWallet() {\r\n    if (!peraWallet) {\r\n        peraWallet = await initPeraWallet();\r\n    }\r\n\r\n    if (peraWallet) {\r\n        try {\r\n            const accounts = await peraWallet.reconnectSession();\r\n            if (accounts && accounts.length > 0) {\r\n                isConnected = true;\r\n                connectedAddress = accounts[0];\r\n                logger.debug('Wallet reconnected:', connectedAddress);\r\n                return connectedAddress;\r\n            }\r\n        } catch (error) {\r\n            logger.debug('No previous session to reconnect');\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n/**\r\n * Get wallet connector object (for use with SDK)\r\n * @returns {Object} Wallet connector with signTransaction method\r\n */\r\nexport function getWalletConnector() {\r\n    if (!isConnected) {\r\n        throw new Error('Wallet not connected');\r\n    }\r\n\r\n    return {\r\n        address: connectedAddress,\r\n        signTransaction: async (txn) => {\r\n            return await signTransaction(txn);\r\n        },\r\n        signTransactions: async (txns) => {\r\n            return await signTransactions(txns);\r\n        }\r\n    };\r\n}\r\n\r\nexport default {\r\n    initPeraWallet,\r\n    connectWallet,\r\n    disconnectWallet,\r\n    getConnectedAddress,\r\n    isWalletConnected,\r\n    signTransactions,\r\n    signTransaction,\r\n    reconnectWallet,\r\n    getWalletConnector\r\n};\r\n\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;;;AAED;AACA;;;AAEA,IAAI,aAAa;AACjB,IAAI,cAAc;AAClB,IAAI,mBAAmB;AAKhB,eAAe;IAClB,wCAAmC;QAC/B,2IAAM,CAAC,IAAI,CAAC;QACZ,OAAO;IACX;;;AAgBJ;AAMO,eAAe;IAClB,IAAI,CAAC,YAAY;QACb,aAAa,MAAM;IACvB;IAEA,IAAI,CAAC,YAAY;QACb,MAAM,IAAI,MAAM;IACpB;IAEA,IAAI;QACA,MAAM,WAAW,MAAM,WAAW,OAAO;QAEzC,IAAI,YAAY,SAAS,MAAM,GAAG,GAAG;YACjC,cAAc;YACd,mBAAmB,QAAQ,CAAC,EAAE;YAC9B,2IAAM,CAAC,KAAK,CAAC,qBAAqB;YAClC,OAAO;QACX,OAAO;YACH,MAAM,IAAI,MAAM;QACpB;IACJ,EAAE,OAAO,OAAO;QACZ,IAAI,MAAM,IAAI,EAAE,SAAS,wBAAwB;YAC7C,2IAAM,CAAC,KAAK,CAAC,4BAA4B;QAC7C;QACA,MAAM;IACV;AACJ;AAKO,eAAe;IAClB,IAAI,YAAY;QACZ,IAAI;YACA,MAAM,WAAW,UAAU;YAC3B,cAAc;YACd,mBAAmB;YACnB,2IAAM,CAAC,KAAK,CAAC;QACjB,EAAE,OAAO,OAAO;YACZ,2IAAM,CAAC,KAAK,CAAC,+BAA+B;QAChD;IACJ;AACJ;AAMO,SAAS;IACZ,OAAO;AACX;AAMO,SAAS;IACZ,OAAO,eAAe,qBAAqB;AAC/C;AAOO,eAAe,iBAAiB,YAAY;IAC/C,IAAI,CAAC,eAAe,CAAC,YAAY;QAC7B,MAAM,IAAI,MAAM;IACpB;IAEA,IAAI;QACA,4CAA4C;QAC5C,MAAM,aAAa,MAAM,WAAW,eAAe,CAAC,MAAM,OAAO,CAAC,gBAAgB,eAAe;YAAC;SAAa;QAC/G,2IAAM,CAAC,KAAK,CAAC;QACb,OAAO,MAAM,OAAO,CAAC,cAAc,aAAa;YAAC;SAAW;IAChE,EAAE,OAAO,OAAO;QACZ,IAAI,MAAM,IAAI,EAAE,SAAS,qBAAqB;YAC1C,2IAAM,CAAC,KAAK,CAAC,+BAA+B;QAChD;QACA,MAAM;IACV;AACJ;AAOO,eAAe,gBAAgB,WAAW;IAC7C,MAAM,SAAS,MAAM,iBAAiB;QAAC;KAAY;IACnD,OAAO,MAAM,CAAC,EAAE;AACpB;AAKO,eAAe;IAClB,IAAI,CAAC,YAAY;QACb,aAAa,MAAM;IACvB;IAEA,IAAI,YAAY;QACZ,IAAI;YACA,MAAM,WAAW,MAAM,WAAW,gBAAgB;YAClD,IAAI,YAAY,SAAS,MAAM,GAAG,GAAG;gBACjC,cAAc;gBACd,mBAAmB,QAAQ,CAAC,EAAE;gBAC9B,2IAAM,CAAC,KAAK,CAAC,uBAAuB;gBACpC,OAAO;YACX;QACJ,EAAE,OAAO,OAAO;YACZ,2IAAM,CAAC,KAAK,CAAC;YACb,OAAO;QACX;IACJ;IAEA,OAAO;AACX;AAMO,SAAS;IACZ,IAAI,CAAC,aAAa;QACd,MAAM,IAAI,MAAM;IACpB;IAEA,OAAO;QACH,SAAS;QACT,iBAAiB,OAAO;YACpB,OAAO,MAAM,gBAAgB;QACjC;QACA,kBAAkB,OAAO;YACrB,OAAO,MAAM,iBAAiB;QAClC;IACJ;AACJ;uCAEe;IACX;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACJ","debugId":null}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/billing.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - Billing Engine\r\n * Handles pay-as-you-use billing: sessions, ticks, payments\r\n */\r\n\r\nimport { getConfig, isDemoMode } from './config.js';\r\nimport { logger, generateId, msToMinutes, eurToPLYMinor } from './utils.js';\r\nimport { transfer } from './wallet.js';\r\nimport { getWalletConnector, isWalletConnected } from './wallet-connect.js';\r\n\r\n// Active sessions storage\r\nconst activeSessions = new Map();\r\n\r\n/**\r\n * Start a billing session\r\n * @param {Object} params - Session parameters\r\n * @param {string} params.contentId - Content ID\r\n * @param {number} params.pricePerMinute - Price per minute in EUR\r\n * @param {string} params.userAddress - User's Algorand address\r\n * @param {Object} params.metadata - Optional metadata\r\n * @returns {Promise<Object>} Session object\r\n */\r\nexport async function startSession({ contentId, pricePerMinute, userAddress, metadata = {} }) {\r\n  if (!contentId || !pricePerMinute || !userAddress) {\r\n    throw new Error('Missing required parameters: contentId, pricePerMinute, userAddress');\r\n  }\r\n  \r\n  if (pricePerMinute <= 0) {\r\n    throw new Error('Price per minute must be positive');\r\n  }\r\n  \r\n  // Use WalletConnect address if connected, otherwise use provided address\r\n  let finalUserAddress = userAddress;\r\n  if (isWalletConnected()) {\r\n    const { getConnectedAddress } = await import('./wallet-connect.js');\r\n    const connectedAddr = getConnectedAddress();\r\n    if (connectedAddr) {\r\n      finalUserAddress = connectedAddr;\r\n      logger.debug('Using WalletConnect address:', connectedAddr);\r\n    }\r\n  }\r\n  \r\n  const sessionId = generateId('session');\r\n  const session = {\r\n    sessionId,\r\n    contentId,\r\n    pricePerMinute,\r\n    userAddress: finalUserAddress,\r\n    status: 'active',\r\n    startTime: Date.now(),\r\n    totalPlayedMs: 0,\r\n    totalChargeEUR: 0,\r\n    totalChargeMinor: 0,\r\n    ticks: [],\r\n    metadata\r\n  };\r\n  \r\n  activeSessions.set(sessionId, session);\r\n  \r\n  logger.debug(`Session started: ${sessionId} for content ${contentId}`);\r\n  \r\n  return session;\r\n}\r\n\r\n/**\r\n * Generate tick ID\r\n */\r\nfunction generateTickId(sessionId) {\r\n  return `${sessionId}-tick-${Date.now()}`;\r\n}\r\n\r\n/**\r\n * Send a billing tick (per-minute charge)\r\n * @param {Object} params - Tick parameters\r\n * @param {string} params.sessionId - Session ID\r\n * @param {number} params.playedMs - Played time in milliseconds\r\n * @param {string} params.tickId - Unique tick ID (optional, auto-generated)\r\n * @returns {Promise<Object>} Tick result\r\n */\r\nexport async function sendTick({ sessionId, playedMs, tickId = null }) {\r\n  const session = activeSessions.get(sessionId);\r\n  \r\n  if (!session) {\r\n    throw new Error(`Session not found: ${sessionId}`);\r\n  }\r\n  \r\n  if (session.status !== 'active') {\r\n    throw new Error(`Session is not active: ${session.status}`);\r\n  }\r\n  \r\n  if (playedMs <= 0) {\r\n    throw new Error('Played time must be positive');\r\n  }\r\n  \r\n  // Generate tick ID if not provided\r\n  const finalTickId = tickId || generateTickId(sessionId);\r\n  \r\n  // Calculate charge\r\n  const minutes = msToMinutes(playedMs);\r\n  const chargeEUR = session.pricePerMinute * minutes;\r\n  const chargeMinor = eurToPLYMinor(chargeEUR);\r\n  \r\n  logger.debug(`Tick ${finalTickId}: ${minutes.toFixed(2)} min = €${chargeEUR.toFixed(2)} (${chargeMinor} PLY minor)`);\r\n  \r\n  // Execute payment using WalletConnect if available\r\n  let txId = null;\r\n  let paymentSuccess = false;\r\n  \r\n  if (!isDemoMode() && isWalletConnected() && session.userAddress) {\r\n    try {\r\n      const config = getConfig();\r\n      const providerAddr = config.providerAddr;\r\n      \r\n      if (!providerAddr) {\r\n        logger.warn('Provider address not configured, skipping payment');\r\n      } else {\r\n        // Get wallet connector for signing\r\n        const walletConnector = getWalletConnector();\r\n        \r\n        // Calculate fee split\r\n        const feePct = config.platformFeePct || 500; // 5% default\r\n        const feeMinor = Math.floor((chargeMinor * feePct) / 10000);\r\n        const providerAmount = chargeMinor - feeMinor;\r\n        \r\n        // Transfer to provider using WalletConnect\r\n        const result = await transfer(\r\n          session.userAddress,\r\n          providerAddr,\r\n          providerAmount,\r\n          walletConnector // Use WalletConnect signer\r\n        );\r\n        \r\n        txId = result.txId;\r\n        paymentSuccess = result.confirmed;\r\n        \r\n        // Transfer fee to platform (if configured)\r\n        if (feeMinor > 0 && config.platformAddr) {\r\n          try {\r\n            await transfer(\r\n              session.userAddress,\r\n              config.platformAddr,\r\n              feeMinor,\r\n              walletConnector // Use WalletConnect signer\r\n            );\r\n          } catch (error) {\r\n            logger.error('Error transferring platform fee:', error);\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logger.error('Payment error:', error);\r\n      // Continue even if payment fails (will be retried)\r\n    }\r\n  } else {\r\n    // Demo mode or wallet not connected\r\n    txId = `DEMO-TX-${Date.now()}`;\r\n    paymentSuccess = true;\r\n    logger.debug('Demo mode: payment simulated');\r\n  }\r\n  \r\n  // Update session\r\n  session.totalPlayedMs += playedMs;\r\n  session.totalChargeEUR += chargeEUR;\r\n  session.totalChargeMinor += chargeMinor;\r\n  \r\n  const tick = {\r\n    tickId: finalTickId,\r\n    timestamp: Date.now(),\r\n    playedMs,\r\n    minutes,\r\n    chargeEUR,\r\n    chargeMinor,\r\n    txId,\r\n    paymentSuccess\r\n  };\r\n  \r\n  session.ticks.push(tick);\r\n  \r\n  logger.debug(`Tick ${finalTickId} processed: ${paymentSuccess ? 'paid' : 'pending'}`);\r\n  \r\n  return tick;\r\n}\r\n\r\n/**\r\n * Stop a billing session\r\n * @param {string} sessionId - Session ID\r\n * @returns {Promise<Object>} Session summary\r\n */\r\nexport async function stopSession(sessionId) {\r\n  const session = activeSessions.get(sessionId);\r\n  \r\n  if (!session) {\r\n    throw new Error(`Session not found: ${sessionId}`);\r\n  }\r\n  \r\n  if (session.status === 'stopped') {\r\n    logger.warn(`Session ${sessionId} already stopped`);\r\n    return session;\r\n  }\r\n  \r\n  session.status = 'stopped';\r\n  session.endTime = Date.now();\r\n  session.durationMs = session.endTime - session.startTime;\r\n  session.totalMinutes = msToMinutes(session.totalPlayedMs);\r\n  \r\n  logger.debug(`Session stopped: ${sessionId}, total: ${session.totalMinutes.toFixed(2)} min, €${session.totalChargeEUR.toFixed(2)}`);\r\n  \r\n  // Return summary\r\n  return {\r\n    sessionId: session.sessionId,\r\n    contentId: session.contentId,\r\n    status: session.status,\r\n    startTime: session.startTime,\r\n    endTime: session.endTime,\r\n    durationMs: session.durationMs,\r\n    totalPlayedMs: session.totalPlayedMs,\r\n    totalMinutes: session.totalMinutes,\r\n    totalChargeEUR: session.totalChargeEUR,\r\n    totalChargeMinor: session.totalChargeMinor,\r\n    ticksCount: session.ticks.length,\r\n    ticks: session.ticks\r\n  };\r\n}\r\n\r\n/**\r\n * Get active session\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object|null} Session object or null\r\n */\r\nexport function getSession(sessionId) {\r\n  return activeSessions.get(sessionId) || null;\r\n}\r\n\r\n/**\r\n * Get all active sessions\r\n * @returns {Array} Array of active sessions\r\n */\r\nexport function getActiveSessions() {\r\n  return Array.from(activeSessions.values()).filter(s => s.status === 'active');\r\n}\r\n\r\n/**\r\n * Get session history\r\n * @param {string} userAddress - User address (optional)\r\n * @returns {Array} Array of sessions\r\n */\r\nexport function getSessionHistory(userAddress = null) {\r\n  const sessions = Array.from(activeSessions.values());\r\n  \r\n  if (userAddress) {\r\n    return sessions.filter(s => s.userAddress === userAddress);\r\n  }\r\n  \r\n  return sessions;\r\n}\r\n\r\nexport default {\r\n  startSession,\r\n  sendTick,\r\n  stopSession,\r\n  getSession,\r\n  getActiveSessions,\r\n  getSessionHistory\r\n};\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;AAED;AACA;AACA;AACA;;;;;AAEA,0BAA0B;AAC1B,MAAM,iBAAiB,IAAI;AAWpB,eAAe,aAAa,EAAE,SAAS,EAAE,cAAc,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,EAAE;IAC1F,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,aAAa;QACjD,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,kBAAkB,GAAG;QACvB,MAAM,IAAI,MAAM;IAClB;IAEA,yEAAyE;IACzE,IAAI,mBAAmB;IACvB,IAAI,IAAA,kKAAiB,KAAI;QACvB,MAAM,EAAE,mBAAmB,EAAE,GAAG;QAChC,MAAM,gBAAgB;QACtB,IAAI,eAAe;YACjB,mBAAmB;YACnB,2IAAM,CAAC,KAAK,CAAC,gCAAgC;QAC/C;IACF;IAEA,MAAM,YAAY,IAAA,+IAAU,EAAC;IAC7B,MAAM,UAAU;QACd;QACA;QACA;QACA,aAAa;QACb,QAAQ;QACR,WAAW,KAAK,GAAG;QACnB,eAAe;QACf,gBAAgB;QAChB,kBAAkB;QAClB,OAAO,EAAE;QACT;IACF;IAEA,eAAe,GAAG,CAAC,WAAW;IAE9B,2IAAM,CAAC,KAAK,CAAC,CAAC,iBAAiB,EAAE,UAAU,aAAa,EAAE,WAAW;IAErE,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,eAAe,SAAS;IAC/B,OAAO,GAAG,UAAU,MAAM,EAAE,KAAK,GAAG,IAAI;AAC1C;AAUO,eAAe,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,IAAI,EAAE;IACnE,MAAM,UAAU,eAAe,GAAG,CAAC;IAEnC,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE,WAAW;IACnD;IAEA,IAAI,QAAQ,MAAM,KAAK,UAAU;QAC/B,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,QAAQ,MAAM,EAAE;IAC5D;IAEA,IAAI,YAAY,GAAG;QACjB,MAAM,IAAI,MAAM;IAClB;IAEA,mCAAmC;IACnC,MAAM,cAAc,UAAU,eAAe;IAE7C,mBAAmB;IACnB,MAAM,UAAU,IAAA,gJAAW,EAAC;IAC5B,MAAM,YAAY,QAAQ,cAAc,GAAG;IAC3C,MAAM,cAAc,IAAA,kJAAa,EAAC;IAElC,2IAAM,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,YAAY,EAAE,EAAE,QAAQ,OAAO,CAAC,GAAG,QAAQ,EAAE,UAAU,OAAO,CAAC,GAAG,EAAE,EAAE,YAAY,WAAW,CAAC;IAEnH,mDAAmD;IACnD,IAAI,OAAO;IACX,IAAI,iBAAiB;IAErB,IAAI,CAAC,IAAA,gJAAU,OAAM,IAAA,kKAAiB,OAAM,QAAQ,WAAW,EAAE;QAC/D,IAAI;YACF,MAAM,SAAS,IAAA,+IAAS;YACxB,MAAM,eAAe,OAAO,YAAY;YAExC,IAAI,CAAC,cAAc;gBACjB,2IAAM,CAAC,IAAI,CAAC;YACd,OAAO;gBACL,mCAAmC;gBACnC,MAAM,kBAAkB,IAAA,mKAAkB;gBAE1C,sBAAsB;gBACtB,MAAM,SAAS,OAAO,cAAc,IAAI,KAAK,aAAa;gBAC1D,MAAM,WAAW,KAAK,KAAK,CAAC,AAAC,cAAc,SAAU;gBACrD,MAAM,iBAAiB,cAAc;gBAErC,2CAA2C;gBAC3C,MAAM,SAAS,MAAM,IAAA,8IAAQ,EAC3B,QAAQ,WAAW,EACnB,cACA,gBACA,gBAAgB,2BAA2B;;gBAG7C,OAAO,OAAO,IAAI;gBAClB,iBAAiB,OAAO,SAAS;gBAEjC,2CAA2C;gBAC3C,IAAI,WAAW,KAAK,OAAO,YAAY,EAAE;oBACvC,IAAI;wBACF,MAAM,IAAA,8IAAQ,EACZ,QAAQ,WAAW,EACnB,OAAO,YAAY,EACnB,UACA,gBAAgB,2BAA2B;;oBAE/C,EAAE,OAAO,OAAO;wBACd,2IAAM,CAAC,KAAK,CAAC,oCAAoC;oBACnD;gBACF;YACF;QACF,EAAE,OAAO,OAAO;YACd,2IAAM,CAAC,KAAK,CAAC,kBAAkB;QAC/B,mDAAmD;QACrD;IACF,OAAO;QACL,oCAAoC;QACpC,OAAO,CAAC,QAAQ,EAAE,KAAK,GAAG,IAAI;QAC9B,iBAAiB;QACjB,2IAAM,CAAC,KAAK,CAAC;IACf;IAEA,iBAAiB;IACjB,QAAQ,aAAa,IAAI;IACzB,QAAQ,cAAc,IAAI;IAC1B,QAAQ,gBAAgB,IAAI;IAE5B,MAAM,OAAO;QACX,QAAQ;QACR,WAAW,KAAK,GAAG;QACnB;QACA;QACA;QACA;QACA;QACA;IACF;IAEA,QAAQ,KAAK,CAAC,IAAI,CAAC;IAEnB,2IAAM,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,YAAY,YAAY,EAAE,iBAAiB,SAAS,WAAW;IAEpF,OAAO;AACT;AAOO,eAAe,YAAY,SAAS;IACzC,MAAM,UAAU,eAAe,GAAG,CAAC;IAEnC,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE,WAAW;IACnD;IAEA,IAAI,QAAQ,MAAM,KAAK,WAAW;QAChC,2IAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,UAAU,gBAAgB,CAAC;QAClD,OAAO;IACT;IAEA,QAAQ,MAAM,GAAG;IACjB,QAAQ,OAAO,GAAG,KAAK,GAAG;IAC1B,QAAQ,UAAU,GAAG,QAAQ,OAAO,GAAG,QAAQ,SAAS;IACxD,QAAQ,YAAY,GAAG,IAAA,gJAAW,EAAC,QAAQ,aAAa;IAExD,2IAAM,CAAC,KAAK,CAAC,CAAC,iBAAiB,EAAE,UAAU,SAAS,EAAE,QAAQ,YAAY,CAAC,OAAO,CAAC,GAAG,OAAO,EAAE,QAAQ,cAAc,CAAC,OAAO,CAAC,IAAI;IAElI,iBAAiB;IACjB,OAAO;QACL,WAAW,QAAQ,SAAS;QAC5B,WAAW,QAAQ,SAAS;QAC5B,QAAQ,QAAQ,MAAM;QACtB,WAAW,QAAQ,SAAS;QAC5B,SAAS,QAAQ,OAAO;QACxB,YAAY,QAAQ,UAAU;QAC9B,eAAe,QAAQ,aAAa;QACpC,cAAc,QAAQ,YAAY;QAClC,gBAAgB,QAAQ,cAAc;QACtC,kBAAkB,QAAQ,gBAAgB;QAC1C,YAAY,QAAQ,KAAK,CAAC,MAAM;QAChC,OAAO,QAAQ,KAAK;IACtB;AACF;AAOO,SAAS,WAAW,SAAS;IAClC,OAAO,eAAe,GAAG,CAAC,cAAc;AAC1C;AAMO,SAAS;IACd,OAAO,MAAM,IAAI,CAAC,eAAe,MAAM,IAAI,MAAM,CAAC,CAAA,IAAK,EAAE,MAAM,KAAK;AACtE;AAOO,SAAS,kBAAkB,cAAc,IAAI;IAClD,MAAM,WAAW,MAAM,IAAI,CAAC,eAAe,MAAM;IAEjD,IAAI,aAAa;QACf,OAAO,SAAS,MAAM,CAAC,CAAA,IAAK,EAAE,WAAW,KAAK;IAChD;IAEA,OAAO;AACT;uCAEe;IACb;IACA;IACA;IACA;IACA;IACA;AACF","debugId":null}},
    {"offset": {"line": 814, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/auth.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - Authentication Module\r\n * Handles JWT tokens and API key management\r\n */\r\n\r\nimport { logger } from './utils.js';\r\nimport { getConfig } from './config.js';\r\n\r\nlet apiKey = null;\r\nlet jwtToken = null;\r\nlet tokenExpiry = null;\r\n\r\n/**\r\n * Set API key\r\n * @param {string} key - API key\r\n */\r\nexport function setApiKey(key) {\r\n  apiKey = key;\r\n  logger.debug('API key set');\r\n}\r\n\r\n/**\r\n * Get API key\r\n * @returns {string|null}\r\n */\r\nexport function getApiKey() {\r\n  if (!apiKey) {\r\n    const config = getConfig();\r\n    apiKey = config.apiKey || null;\r\n  }\r\n  return apiKey;\r\n}\r\n\r\n/**\r\n * Set JWT token\r\n * @param {string} token - JWT token\r\n * @param {number} expiresIn - Expiration time in seconds\r\n */\r\nexport function setJWTToken(token, expiresIn = 3600) {\r\n  jwtToken = token;\r\n  tokenExpiry = Date.now() + (expiresIn * 1000);\r\n  logger.debug('JWT token set, expires at:', new Date(tokenExpiry));\r\n}\r\n\r\n/**\r\n * Get JWT token\r\n * @returns {string|null}\r\n */\r\nexport function getJWTToken() {\r\n  // Check if token is expired\r\n  if (jwtToken && tokenExpiry && Date.now() >= tokenExpiry) {\r\n    logger.warn('JWT token expired');\r\n    jwtToken = null;\r\n    tokenExpiry = null;\r\n  }\r\n  return jwtToken;\r\n}\r\n\r\n/**\r\n * Check if JWT token is valid\r\n * @returns {boolean}\r\n */\r\nexport function isTokenValid() {\r\n  const token = getJWTToken();\r\n  return token !== null && tokenExpiry !== null && Date.now() < tokenExpiry;\r\n}\r\n\r\n/**\r\n * Clear authentication (logout)\r\n */\r\nexport function clearAuth() {\r\n  apiKey = null;\r\n  jwtToken = null;\r\n  tokenExpiry = null;\r\n  logger.debug('Authentication cleared');\r\n}\r\n\r\n/**\r\n * Get authorization header value\r\n * @returns {string|null}\r\n */\r\nexport function getAuthHeader() {\r\n  const token = getJWTToken();\r\n  if (token) {\r\n    return `Bearer ${token}`;\r\n  }\r\n  \r\n  const key = getApiKey();\r\n  if (key) {\r\n    return `ApiKey ${key}`;\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * Get headers for API requests\r\n * @param {Object} additionalHeaders - Additional headers to include\r\n * @returns {Object}\r\n */\r\nexport function getHeaders(additionalHeaders = {}) {\r\n  const headers = {\r\n    'Content-Type': 'application/json',\r\n    ...additionalHeaders\r\n  };\r\n  \r\n  const authHeader = getAuthHeader();\r\n  if (authHeader) {\r\n    headers['Authorization'] = authHeader;\r\n  }\r\n  \r\n  return headers;\r\n}\r\n\r\n/**\r\n * Authenticate with API\r\n * @param {string} userId - User ID\r\n * @param {string} password - Password (or API key)\r\n * @returns {Promise<Object>} Auth response with token\r\n */\r\nexport async function authenticate(userId, password) {\r\n  try {\r\n    const config = getConfig();\r\n    const response = await fetch(`${config.apiBaseUrl}/auth/login`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({ userId, password })\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Authentication failed: ${response.statusText}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    \r\n    if (data.token) {\r\n      setJWTToken(data.token, data.expiresIn || 3600);\r\n    }\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    logger.error('Authentication error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport default {\r\n  setApiKey,\r\n  getApiKey,\r\n  setJWTToken,\r\n  getJWTToken,\r\n  isTokenValid,\r\n  clearAuth,\r\n  getAuthHeader,\r\n  getHeaders,\r\n  authenticate\r\n};\r\n\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;;;AAED;AACA;;;AAEA,IAAI,SAAS;AACb,IAAI,WAAW;AACf,IAAI,cAAc;AAMX,SAAS,UAAU,GAAG;IAC3B,SAAS;IACT,2IAAM,CAAC,KAAK,CAAC;AACf;AAMO,SAAS;IACd,IAAI,CAAC,QAAQ;QACX,MAAM,SAAS,IAAA,+IAAS;QACxB,SAAS,OAAO,MAAM,IAAI;IAC5B;IACA,OAAO;AACT;AAOO,SAAS,YAAY,KAAK,EAAE,YAAY,IAAI;IACjD,WAAW;IACX,cAAc,KAAK,GAAG,KAAM,YAAY;IACxC,2IAAM,CAAC,KAAK,CAAC,8BAA8B,IAAI,KAAK;AACtD;AAMO,SAAS;IACd,4BAA4B;IAC5B,IAAI,YAAY,eAAe,KAAK,GAAG,MAAM,aAAa;QACxD,2IAAM,CAAC,IAAI,CAAC;QACZ,WAAW;QACX,cAAc;IAChB;IACA,OAAO;AACT;AAMO,SAAS;IACd,MAAM,QAAQ;IACd,OAAO,UAAU,QAAQ,gBAAgB,QAAQ,KAAK,GAAG,KAAK;AAChE;AAKO,SAAS;IACd,SAAS;IACT,WAAW;IACX,cAAc;IACd,2IAAM,CAAC,KAAK,CAAC;AACf;AAMO,SAAS;IACd,MAAM,QAAQ;IACd,IAAI,OAAO;QACT,OAAO,CAAC,OAAO,EAAE,OAAO;IAC1B;IAEA,MAAM,MAAM;IACZ,IAAI,KAAK;QACP,OAAO,CAAC,OAAO,EAAE,KAAK;IACxB;IAEA,OAAO;AACT;AAOO,SAAS,WAAW,oBAAoB,CAAC,CAAC;IAC/C,MAAM,UAAU;QACd,gBAAgB;QAChB,GAAG,iBAAiB;IACtB;IAEA,MAAM,aAAa;IACnB,IAAI,YAAY;QACd,OAAO,CAAC,gBAAgB,GAAG;IAC7B;IAEA,OAAO;AACT;AAQO,eAAe,aAAa,MAAM,EAAE,QAAQ;IACjD,IAAI;QACF,MAAM,SAAS,IAAA,+IAAS;QACxB,MAAM,WAAW,MAAM,MAAM,GAAG,OAAO,UAAU,CAAC,WAAW,CAAC,EAAE;YAC9D,QAAQ;YACR,SAAS;gBACP,gBAAgB;YAClB;YACA,MAAM,KAAK,SAAS,CAAC;gBAAE;gBAAQ;YAAS;QAC1C;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,SAAS,UAAU,EAAE;QACjE;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,KAAK,KAAK,EAAE;YACd,YAAY,KAAK,KAAK,EAAE,KAAK,SAAS,IAAI;QAC5C;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,2IAAM,CAAC,KAAK,CAAC,yBAAyB;QACtC,MAAM;IACR;AACF;uCAEe;IACb;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACF","debugId":null}},
    {"offset": {"line": 944, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/analytics.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - Analytics Module\r\n * Fetches user/session reports and analytics data\r\n */\r\n\r\nimport { getConfig, isDemoMode } from './config.js';\r\nimport { getHeaders } from './auth.js';\r\nimport { logger, formatCurrency, formatDuration } from './utils.js';\r\nimport { getSessionHistory } from './billing.js';\r\n\r\n/**\r\n * Get user analytics\r\n * @param {Object} params - Analytics parameters\r\n * @param {string} params.userId - User ID\r\n * @param {string} params.from - Start date (ISO string or Date)\r\n * @param {string} params.to - End date (ISO string or Date)\r\n * @returns {Promise<Object>} Analytics data\r\n */\r\nexport async function getUserAnalytics({ userId, from, to }) {\r\n  if (!userId) {\r\n    throw new Error('User ID is required');\r\n  }\r\n  \r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock analytics');\r\n    return getMockAnalytics(userId);\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const params = new URLSearchParams({\r\n      userId,\r\n      ...(from && { from: typeof from === 'string' ? from : from.toISOString() }),\r\n      ...(to && { to: typeof to === 'string' ? to : to.toISOString() })\r\n    });\r\n    \r\n    const response = await fetch(`${config.apiBaseUrl}/analytics/user?${params}`, {\r\n      method: 'GET',\r\n      headers: getHeaders()\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Analytics request failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error getting user analytics:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get partner analytics\r\n * @param {Object} params - Analytics parameters\r\n * @param {string} params.partnerId - Partner ID\r\n * @param {string} params.from - Start date (ISO string or Date)\r\n * @param {string} params.to - End date (ISO string or Date)\r\n * @returns {Promise<Object>} Partner analytics data\r\n */\r\nexport async function getPartnerAnalytics({ partnerId, from, to }) {\r\n  if (!partnerId) {\r\n    throw new Error('Partner ID is required');\r\n  }\r\n  \r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock partner analytics');\r\n    return getMockPartnerAnalytics(partnerId);\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const params = new URLSearchParams({\r\n      partnerId,\r\n      ...(from && { from: typeof from === 'string' ? from : from.toISOString() }),\r\n      ...(to && { to: typeof to === 'string' ? to : to.toISOString() })\r\n    });\r\n    \r\n    const response = await fetch(`${config.apiBaseUrl}/analytics/partner?${params}`, {\r\n      method: 'GET',\r\n      headers: getHeaders()\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Partner analytics request failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error getting partner analytics:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get session report\r\n * @param {string} sessionId - Session ID\r\n * @returns {Promise<Object>} Session report\r\n */\r\nexport async function getSessionReport(sessionId) {\r\n  if (!sessionId) {\r\n    throw new Error('Session ID is required');\r\n  }\r\n  \r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock session report');\r\n    return getMockSessionReport(sessionId);\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const response = await fetch(`${config.apiBaseUrl}/analytics/session/${sessionId}`, {\r\n      method: 'GET',\r\n      headers: getHeaders()\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Session report request failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error getting session report:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get usage statistics\r\n * @param {Object} params - Statistics parameters\r\n * @param {string} params.userId - User ID (optional)\r\n * @param {string} params.contentId - Content ID (optional)\r\n * @param {string} params.from - Start date (optional)\r\n * @param {string} params.to - End date (optional)\r\n * @returns {Promise<Object>} Usage statistics\r\n */\r\nexport async function getUsageStats(params = {}) {\r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock usage stats');\r\n    return getMockUsageStats();\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const queryParams = new URLSearchParams();\r\n    \r\n    if (params.userId) queryParams.append('userId', params.userId);\r\n    if (params.contentId) queryParams.append('contentId', params.contentId);\r\n    if (params.from) queryParams.append('from', typeof params.from === 'string' ? params.from : params.from.toISOString());\r\n    if (params.to) queryParams.append('to', typeof params.to === 'string' ? params.to : params.to.toISOString());\r\n    \r\n    const response = await fetch(`${config.apiBaseUrl}/analytics/stats?${queryParams}`, {\r\n      method: 'GET',\r\n      headers: getHeaders()\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Usage stats request failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error getting usage stats:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Mock data generators for demo mode\r\nfunction getMockAnalytics(userId) {\r\n  return {\r\n    userId,\r\n    period: {\r\n      from: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\r\n      to: new Date().toISOString()\r\n    },\r\n    totalSessions: 12,\r\n    totalWatchTime: 180 * 60 * 1000, // 180 minutes\r\n    totalSpent: 3.60,\r\n    averageSessionDuration: 15 * 60 * 1000, // 15 minutes\r\n    favoriteContent: [\r\n      { contentId: 'film123', watchTime: 60 * 60 * 1000, sessions: 4 },\r\n      { contentId: 'series456', watchTime: 45 * 60 * 1000, sessions: 3 }\r\n    ]\r\n  };\r\n}\r\n\r\nfunction getMockPartnerAnalytics(partnerId) {\r\n  return {\r\n    partnerId,\r\n    period: {\r\n      from: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\r\n      to: new Date().toISOString()\r\n    },\r\n    totalUsers: 150,\r\n    totalSessions: 450,\r\n    totalRevenue: 90.00,\r\n    totalWatchTime: 2250 * 60 * 1000, // 2250 minutes\r\n    topContent: [\r\n      { contentId: 'film123', revenue: 45.00, sessions: 120 },\r\n      { contentId: 'series456', revenue: 30.00, sessions: 80 }\r\n    ],\r\n    engagement: {\r\n      averageSessionDuration: 15 * 60 * 1000,\r\n      retentionRate: 0.65\r\n    }\r\n  };\r\n}\r\n\r\nfunction getMockSessionReport(sessionId) {\r\n  return {\r\n    sessionId,\r\n    userId: 'user123',\r\n    contentId: 'film123',\r\n    startedAt: new Date(Date.now() - 15 * 60 * 1000).toISOString(),\r\n    stoppedAt: new Date().toISOString(),\r\n    duration: 15 * 60 * 1000,\r\n    totalCharged: 0.30,\r\n    ticks: [\r\n      { tickId: 'tick_1', playedMs: 60000, charge: 0.02, timestamp: Date.now() - 14 * 60 * 1000 },\r\n      { tickId: 'tick_2', playedMs: 60000, charge: 0.02, timestamp: Date.now() - 13 * 60 * 1000 }\r\n    ]\r\n  };\r\n}\r\n\r\nfunction getMockUsageStats() {\r\n  return {\r\n    totalUsers: 1000,\r\n    totalSessions: 5000,\r\n    totalWatchTime: 75000 * 60 * 1000, // 75000 minutes\r\n    totalRevenue: 1500.00,\r\n    averageSessionDuration: 15 * 60 * 1000,\r\n    peakHours: [20, 21, 22], // 8-10 PM\r\n    topContent: [\r\n      { contentId: 'film123', views: 500, revenue: 100.00 },\r\n      { contentId: 'series456', views: 300, revenue: 60.00 }\r\n    ]\r\n  };\r\n}\r\n\r\nexport default {\r\n  getUserAnalytics,\r\n  getPartnerAnalytics,\r\n  getSessionReport,\r\n  getUsageStats\r\n};\r\n\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1195, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/api.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - API Wrapper Module\r\n * Backend API wrapper for session management and wallet operations\r\n */\r\n\r\nimport { getConfig, isDemoMode } from './config.js';\r\nimport { getHeaders } from './auth.js';\r\nimport { logger, generateId } from './utils.js';\r\n\r\n/**\r\n * Start a session via API\r\n * @param {Object} params - Session parameters\r\n * @param {string} params.userId - User ID\r\n * @param {string} params.contentId - Content ID\r\n * @param {number} params.pricePerMinute - Price per minute\r\n * @returns {Promise<Object>} Session response\r\n */\r\nexport async function startSession(params) {\r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock session');\r\n    return {\r\n      sessionId: generateId('session'),\r\n      playbackToken: generateId('token'),\r\n      startedAt: new Date().toISOString()\r\n    };\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const response = await fetch(`${config.apiBaseUrl}/session/start`, {\r\n      method: 'POST',\r\n      headers: getHeaders(),\r\n      body: JSON.stringify(params)\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Session start failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error starting session:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Send tick via API\r\n * @param {Object} params - Tick parameters\r\n * @param {string} params.sessionId - Session ID\r\n * @param {number} params.playedMs - Played time in milliseconds\r\n * @param {string} params.tickId - Unique tick ID\r\n * @returns {Promise<Object>} Tick response\r\n */\r\nexport async function sendTick(params) {\r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock tick');\r\n    return {\r\n      success: true,\r\n      charged: 0.02,\r\n      remainingBalance: 4.98,\r\n      txId: `DEMO-TX-${Date.now()}`\r\n    };\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const response = await fetch(`${config.apiBaseUrl}/session/tick`, {\r\n      method: 'POST',\r\n      headers: getHeaders({\r\n        'X-Idempotency-Key': params.tickId || generateId('tick')\r\n      }),\r\n      body: JSON.stringify(params)\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Tick failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error sending tick:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Stop session via API\r\n * @param {string} sessionId - Session ID\r\n * @returns {Promise<Object>} Session summary\r\n */\r\nexport async function stopSession(sessionId) {\r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock session stop');\r\n    return {\r\n      sessionId,\r\n      totalCharged: 0.30,\r\n      duration: 15 * 60 * 1000\r\n    };\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const response = await fetch(`${config.apiBaseUrl}/session/stop`, {\r\n      method: 'POST',\r\n      headers: getHeaders(),\r\n      body: JSON.stringify({ sessionId })\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Session stop failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error stopping session:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get wallet balance via API\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Object>} Balance response\r\n */\r\nexport async function getWalletBalance(userId) {\r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock balance');\r\n    return {\r\n      userId,\r\n      balance: 500.00,\r\n      balanceMinor: 50000,\r\n      currency: 'PLY'\r\n    };\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const response = await fetch(`${config.apiBaseUrl}/wallet/balance/${userId}`, {\r\n      method: 'GET',\r\n      headers: getHeaders()\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Balance request failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error getting wallet balance:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Top up wallet via API\r\n * @param {Object} params - Top-up parameters\r\n * @param {string} params.userId - User ID\r\n * @param {number} params.amount - Amount in EUR\r\n * @param {string} params.paymentMethod - Payment method (e.g., 'card', 'paypal')\r\n * @returns {Promise<Object>} Top-up response\r\n */\r\nexport async function topUpWallet(params) {\r\n  if (isDemoMode()) {\r\n    logger.debug('Demo mode: returning mock top-up');\r\n    return {\r\n      success: true,\r\n      txId: `DEMO-TOPUP-${Date.now()}`,\r\n      amount: params.amount,\r\n      newBalance: 500.00 + params.amount\r\n    };\r\n  }\r\n  \r\n  try {\r\n    const config = getConfig();\r\n    const response = await fetch(`${config.apiBaseUrl}/wallet/topup`, {\r\n      method: 'POST',\r\n      headers: getHeaders(),\r\n      body: JSON.stringify(params)\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Top-up failed: ${response.statusText}`);\r\n    }\r\n    \r\n    return await response.json();\r\n  } catch (error) {\r\n    logger.error('Error topping up wallet:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport default {\r\n  startSession,\r\n  sendTick,\r\n  stopSession,\r\n  getWalletBalance,\r\n  topUpWallet\r\n};\r\n\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1360, "column": 0}, "map": {"version":3,"sources":["file:///C:/Amir/pay-as-play-project/playandpay-sdk/src/index.js"],"sourcesContent":["/**\r\n * Play and Pay SDK - Main Entry Point\r\n * \r\n * @module @playandpay/sdk\r\n * @version 1.0.0\r\n */\r\n\r\nimport { initConfig, getConfig } from './config.js';\r\nimport * as wallet from './wallet.js';\r\nimport * as billing from './billing.js';\r\nimport * as analytics from './analytics.js';\r\nimport * as api from './api.js';\r\nimport * as auth from './auth.js';\r\nimport * as utils from './utils.js';\r\nimport * as walletConnect from './wallet-connect.js';\r\n\r\n/**\r\n * Initialize SDK\r\n * @param {Object} config - Configuration object\r\n * @param {string} config.apiKey - API key (optional)\r\n * @param {string} config.apiBaseUrl - API base URL (optional)\r\n * @param {string} config.network - Network ('testnet' | 'mainnet', default: 'testnet')\r\n * @param {number} config.asaId - PlayCoin ASA ID (optional)\r\n * @param {string} config.providerAddr - Provider address (optional)\r\n * @param {string} config.platformAddr - Platform address (optional)\r\n * @param {number} config.appId - Smart Contract App ID (optional)\r\n * @returns {Object} SDK instance\r\n */\r\nexport function init(config = {}) {\r\n  // Initialize configuration\r\n  const finalConfig = initConfig(config);\r\n  \r\n  // Set API key if provided\r\n  if (config.apiKey) {\r\n    auth.setApiKey(config.apiKey);\r\n  }\r\n  \r\n  return {\r\n    config: finalConfig,\r\n    wallet,\r\n    billing,\r\n    analytics,\r\n    api,\r\n    auth,\r\n    utils\r\n  };\r\n}\r\n\r\n/**\r\n * Quick start: Initialize wallet\r\n * @param {Object} config - Configuration\r\n * @returns {Promise<Object>} Wallet balance\r\n */\r\nexport async function initWallet(config = {}) {\r\n  const sdk = init(config);\r\n  // This is a placeholder - in real usage, user would connect their wallet\r\n  return sdk.wallet;\r\n}\r\n\r\n/**\r\n * Quick start: Start billing\r\n * @param {Object} params - Billing parameters\r\n * @param {string} params.contentId - Content ID\r\n * @param {number} params.pricePerMinute - Price per minute\r\n * @returns {Promise<Object>} Session\r\n */\r\nexport async function startBilling(params) {\r\n  const sdk = init();\r\n  return await sdk.billing.startSession(params);\r\n}\r\n\r\n/**\r\n * Quick start: Get analytics\r\n * @param {Object} params - Analytics parameters\r\n * @returns {Promise<Object>} Analytics data\r\n */\r\nexport async function getAnalytics(params) {\r\n  const sdk = init();\r\n  return await sdk.analytics.getUserAnalytics(params);\r\n}\r\n\r\n// Export all modules\r\nexport {\r\n  wallet,\r\n  billing,\r\n  analytics,\r\n  api,\r\n  auth,\r\n  utils,\r\n  walletConnect,\r\n  initConfig,\r\n  getConfig\r\n};\r\n\r\n// Default export\r\nexport default {\r\n  init,\r\n  initWallet,\r\n  startBilling,\r\n  getAnalytics,\r\n  wallet,\r\n  billing,\r\n  analytics,\r\n  api,\r\n  auth,\r\n  utils,\r\n  walletConnect\r\n};\r\n\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAcO,SAAS,KAAK,SAAS,CAAC,CAAC;IAC9B,2BAA2B;IAC3B,MAAM,cAAc,IAAA,gJAAU,EAAC;IAE/B,0BAA0B;IAC1B,IAAI,OAAO,MAAM,EAAE;QACjB,6IAAc,CAAC,OAAO,MAAM;IAC9B;IAEA,OAAO;QACL,QAAQ;QACR,QAAA;QACA,SAAA;QACA,WAAA;QACA,KAAA;QACA,MAAA;QACA,OAAA;IACF;AACF;AAOO,eAAe,WAAW,SAAS,CAAC,CAAC;IAC1C,MAAM,MAAM,KAAK;IACjB,yEAAyE;IACzE,OAAO,IAAI,MAAM;AACnB;AASO,eAAe,aAAa,MAAM;IACvC,MAAM,MAAM;IACZ,OAAO,MAAM,IAAI,OAAO,CAAC,YAAY,CAAC;AACxC;AAOO,eAAe,aAAa,MAAM;IACvC,MAAM,MAAM;IACZ,OAAO,MAAM,IAAI,SAAS,CAAC,gBAAgB,CAAC;AAC9C;;uCAgBe;IACb;IACA;IACA;IACA;IACA,QAAA;IACA,SAAA;IACA,WAAA;IACA,KAAA;IACA,MAAA;IACA,OAAA;IACA,eAAA;AACF","debugId":null}}]
}